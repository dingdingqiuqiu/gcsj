import{_ as a,c as s,o as i,ae as t}from"./chunks/framework.ChhGBEr5.js";const g=JSON.parse('{"title":"CS61b食用指南(WEEK1)","description":"","frontmatter":{"title":"CS61b食用指南(WEEK1)","date":"2024-03-14T22:21:08.000Z","tags":null,"categories":null},"headers":[],"relativePath":"笔记/Old/CS61b食用指南-WEEK1.md","filePath":"笔记/Old/CS61b食用指南-WEEK1.md","lastUpdated":1743185048000}'),p={name:"笔记/Old/CS61b食用指南-WEEK1.md"};function o(l,e,n,d,c,r){return i(),s("div",null,e[0]||(e[0]=[t(`<p>针对第一周的内容做了具体总结归纳。</p><h2 id="课程" tabindex="-1">课程 <a class="header-anchor" href="#课程" aria-label="Permalink to &quot;课程&quot;">​</a></h2><h2 id="实验01-设置" tabindex="-1">实验01-设置 <a class="header-anchor" href="#实验01-设置" aria-label="Permalink to &quot;实验01-设置&quot;">​</a></h2><h3 id="安装git" tabindex="-1">安装git <a class="header-anchor" href="#安装git" aria-label="Permalink to &quot;安装git&quot;">​</a></h3><blockquote><p>git的自动登录和简单使用在原先的文章中已经有所涉及:</p><p><a href="https://dingdingqiuqiu.github.io/tags/Git/" target="_blank" rel="noreferrer">点此跳转</a></p></blockquote><p>但是，CS61b专门提供了一篇<code>git</code>深度指南。必要时可以做一次汉化实践，先当指南看着。</p><p><a href="https://sp24.datastructur.es/resources/guides/git/" target="_blank" rel="noreferrer">CS61b官方git指南</a></p><p>这里先就此复习下<strong>远程存储库</strong>部分(实际上是CS61b当时的要求)</p><ul><li><code>git clone [remote-repo-URL]</code>：在本地计算机上创建指定存储库的副本。还创建一个工作目录，其中的文件排列方式与下载存储库中的最新快照完全相同。还记录用于后续网络数据传输的远程存储库的 URL，并为其赋予特殊的远程存储库名称“origin”。</li><li><code>git remote add [remote-repo-name] [remote-repo-URL]</code>：记录网络数据传输的新位置。</li><li><code>git remote -v</code>：列出网络数据传输的所有位置。</li><li><code>git pull [remote-repo-name] main</code>：获取文件的最新副本，如 中所示<code>remote-repo-name</code>。</li><li><code>git push [remote-repo-name] main</code>：将文件的最新副本上传到<code>remote-repo-name</code>。</li></ul><p>对于本课程的大部分时间，您只有两个远程存储库：</p><p><code>origin</code>，它是用于保存和提交您的个人工作的远程存储库</p><p><code>sculpture</code>，它是您将从中接收框架代码的远程存储库。</p><p>这里<code>git</code>初始配置贴一个没见过（使用过）的：</p><div class="language-zsh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zsh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> config</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> --global</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull.rebase</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span></span></code></pre></div><blockquote><p><code>pull.rebase</code> 是一个配置项，它决定了 <code>git pull</code> 命令的行为。如果设置为 <code>true</code>，那么在执行 <code>git pull</code> 命令时，Git 会使用 <code>rebase</code> 而不是 <code>merge</code> 来合并远程仓库的新提交。<code>rebase</code> 会把你本地的提交放到远程仓库的新提交之后，这样可以得到一个线性的提交历史，使得历史更加清晰。</p></blockquote><h3 id="这块不懂-建议写篇博客专门实践下。" tabindex="-1">这块不懂，建议写篇博客专门实践下。 <a class="header-anchor" href="#这块不懂-建议写篇博客专门实践下。" aria-label="Permalink to &quot;这块不懂，建议写篇博客专门实践下。&quot;">​</a></h3><p><strong>举例说明</strong></p><p>假设你正在开发一个项目，并且你有一个名为 <code>feature</code> 的分支，你正在这个分支上工作。同时，你的同事在 <code>master</code> 分支上也做了一些改动，并且他们已经将这些改动推送到了远程仓库。</p><p>现在，你想要获取 <code>master</code> 分支上的最新改动。你有两种方式可以做到这一点：<code>merge</code> 和 <code>rebase</code>。如果你执行 <code>git pull</code> 命令，Git 默认会使用 <code>merge</code> 来合并远程仓库的新提交。</p><p>这就是 <code>git config --global pull.rebase false</code> 这个命令的作用。它会设置 Git 的 <code>pull</code> 命令在合并远程仓库的新提交时，使用 <code>merge</code> 而不是 <code>rebase</code>。</p><p>例如，你的提交历史可能会像下面这样：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A - B - C (master)</span></span>
<span class="line"><span>     \\</span></span>
<span class="line"><span>      D - E (feature)</span></span></code></pre></div><p>当你在 <code>feature</code> 分支上执行 <code>git pull origin master</code> 后，如果你的 <code>pull.rebase</code> 配置项被设置为 <code>false</code>，那么你的提交历史会变成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A - B - C - F (master)</span></span>
<span class="line"><span>     \\       /</span></span>
<span class="line"><span>      D - E (feature)</span></span></code></pre></div><p>这里的 <code>F</code> 就是一个新的 “合并提交”，它包含了 <code>master</code> 分支和 <code>feature</code> 分支的所有改动。</p><p>如果你的 <code>pull.rebase</code> 配置项被设置为 <code>true</code>，那么在执行 <code>git pull origin master</code> 后，你的提交历史会变成：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>A - B - C (master)</span></span>
<span class="line"><span>         \\</span></span>
<span class="line"><span>          D&#39; - E&#39; (feature)</span></span></code></pre></div><p>这里的 <code>D&#39;</code> 和 <code>E&#39;</code> 是 <code>D</code> 和 <code>E</code> 的重新应用。它们的改动和 <code>D</code> 和 <code>E</code> 是一样的，但它们是全新的提交，因为它们的父提交是 <code>C</code>，而不是 <code>B</code>。</p><p>所以，<code>git config --global pull.rebase false</code> 这个命令的意思就是在全局范围内，设置 <code>git pull</code> 命令在合并远程仓库的新提交时，使用 <code>merge</code> 而不是 <code>rebase</code>。这是 Git 的默认行为，如果你没有特别的需求，一般不需要执行这个命令。</p><h3 id="git-存储库和-java-库" tabindex="-1">Git 存储库和 Java 库 <a class="header-anchor" href="#git-存储库和-java-库" aria-label="Permalink to &quot;Git 存储库和 Java 库&quot;">​</a></h3><h3 id="java-库" tabindex="-1">Java 库 <a class="header-anchor" href="#java-库" aria-label="Permalink to &quot;Java 库&quot;">​</a></h3><p>就像在 Python 中一样，我们有时想使用其他人编写的库。Java 依赖项管理有点混乱，因此我们提供了一个 git 存储库，其中包含我们将在本课程中使用的所有依赖项。再次确保您的终端已打开。</p><p>导航到您要存储库的文件夹。对于本实验，我们假设您将所有内容放置在名为<strong>cs61b</strong>的文件夹中。如果您愿意，可以选择不同的名称。<code>cs61b</code>导航到您想要的位置、创建目录并进入该目录后（<code>cd cs61b</code>在本例中），它可能看起来像这样：</p><p><img src="https://sp24.datastructur.es/labs/lab01/img/terminal_directory.png" alt="终端目录" loading="lazy"></p><p>进入文件夹后，运行：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>git clone https://github.com/Berkeley-CS61B/library-sp24</span></span></code></pre></div><p>下面是 的目录结构<code>library-sp24</code>。使用查看文件夹内部 <code>ls library-sp24</code>并确保您看到<code>.jar</code>下面列出的文件。还有很多，但我们只列出前几个。如果您使用操作系统的文件资源管理器，该<code>jar</code>部分可能不会显示在文件名中，但这没关系。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>library-sp24</span></span>
<span class="line"><span>├── algs4.jar</span></span>
<span class="line"><span>├── animated-gif-lib-1.4.jar</span></span>
<span class="line"><span>├── antlr4-runtime-4.11.1.jar</span></span>
<span class="line"><span>├── apiguardian-api-1.1.2.jar</span></span>
<span class="line"><span>└── ...</span></span></code></pre></div><h3 id="个人储存库" tabindex="-1">个人储存库 <a class="header-anchor" href="#个人储存库" aria-label="Permalink to &quot;个人储存库&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>CS61b/</span></span></code></pre></div><div class="language-zsh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zsh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> clone</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> git@github.com:dingdingqiuqiu/CS61B-sp24.git</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># git clone git@github.com:dingdingqiuqiu/CS61B-sp21.git</span></span></code></pre></div><div class="language-zsh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zsh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">cd</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> CS61B-sp24</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># cd CS61B-sp21</span></span></code></pre></div><div class="language-zsh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zsh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> branch</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -M</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span></code></pre></div><div class="language-zsh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zsh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> remote</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> skeleton</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> https://github.com/Berkeley-CS61B/skeleton-sp24.git</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># git remote add skeleton https://github.com/Berkeley-CS61B/skeleton-sp21.git</span></span></code></pre></div><div class="language-zsh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zsh</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">git</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> pull</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> skeleton</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> main</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># git pull skeleton master</span></span></code></pre></div><p>课程实验库拉取成功</p><blockquote><p>后续发现sp21有开源的自动评分机器，又开了个sp21的仓库。</p><p>注释部分为sp21版</p><p>将普通用户赋权root组，又配置了下ssh普通用户的rsa密钥。</p><p>gpasswd -a P4yl04d root</p><p>赋权命令</p></blockquote><h3 id="intellij-设置" tabindex="-1">IntelliJ 设置 <a class="header-anchor" href="#intellij-设置" aria-label="Permalink to &quot;IntelliJ 设置&quot;">​</a></h3><p>查看<a href="https://sp24.datastructur.es/resources/guides/intellij/wtfs/" target="_blank" rel="noreferrer">IntelliJ WTFS 指南</a>以获取一些常见问题的解决方案。</p><p>安装CS61b插件</p><p><img src="https://sp24.datastructur.es/labs/lab01/img/plugin_setup2.png" alt="搜索 CS 61B" loading="lazy"></p><p>现在，搜索“Java Visualizer”，然后单击绿色的<strong>安装</strong>按钮来安装该插件。</p><p><img src="https://sp24.datastructur.es/labs/lab01/img/plugin_setup3.png" alt="搜索 Java 可视化工具" loading="lazy"></p><h3 id="安装java" tabindex="-1">安装Java <a class="header-anchor" href="#安装java" aria-label="Permalink to &quot;安装Java&quot;">​</a></h3><blockquote><p>略</p></blockquote><h3 id="习题" tabindex="-1">习题 <a class="header-anchor" href="#习题" aria-label="Permalink to &quot;习题&quot;">​</a></h3><p>打开名为<code>Collatz.java</code>. 尝试运行它，您将看到打印出数字 5。</p><p>该程序应该打印从给定数字开始的<a href="https://en.wikipedia.org/wiki/Collatz_conjecture" target="_blank" rel="noreferrer">Collatz 序列。</a>Collatz 序列定义如下：</p><p>如果 n 是偶数，则下一个数字是 n/2。如果 n 是奇数，则下一个数字是 3n + 1。如果 n 是 1，则序列结束。</p><p>例如，假设我们从 5 开始。由于 5 是奇数，所以下一个数字是 3x5 + 1 = 16。由于 16 是偶数，所以下一个数字是 8。由于 8 是偶数，所以下一个数字是 4。由于 4 是偶数下一个数字是 2。由于 2 是偶数，所以下一个数字是 1。此时我们就完成了。顺序是 5、16、8、4、2、1。</p><p>您的第一个任务是编写一个方法，如下所示：<code>public static int nextNumber(int n)</code>返回下一个数字。例如<code>nextNumber(5)</code>应返回 16。此方法将由 Gradescope 自动评分器进行测试。确保提供该方法的描述作为注释。您的描述应包含在<code>/**</code>和中<code>*/</code>。包含的注释<code>/**</code>也<code>*/</code>称为“Javadoc 注释”或简称为“Javadoc”。如果这些注释需要额外的空间，则可以跨越多行，例如 Javadocs <code>nextNumber</code>。</p><p>Javadoc 可能包含可选标签，例如<code>@param</code>. 除了 标签外，我们不要求您在 61B 中使用任何类似的标签<code>@source</code>。<code>@source</code>每当您在项目上获得重要帮助时，请使用该标签。<code>@source</code>硬件或实验室不需要该标签，但我们还是推荐它，因为引用来源是一个良好的学术和专业习惯。</p><p>一些 Java 技巧：</p><ul><li>运算<code>%</code>符实现余数。例如， 的值<code>x % 4</code>将为 <code>0</code>、<code>1</code>、<code>2</code>或<code>3</code>。</li><li>该<code>==</code>运算符比较两个值是否不相等。代码片段<code>if (n % 4 == 1)</code>读作“如果 n 除以 4 的余数等于 1”。</li></ul><p>编写完成后<code>nextNumber</code>，填写<code>main</code>方法，使其打印出从 开始的 Collatz 序列<code>n = 5</code>。例如，如果<code>n = 5</code>，您的程序应该打印<code>5 16 8 4 2 1</code>。如果1后面有一个额外的空格就可以了。</p><p>有趣的事实：对于所有数字，Collatz 序列似乎都终止于 1。然而，到目前为止，没有人能够证明这对于所有可能的起始值都是正确的，但已检查了大约 2^68 以内的所有值。正如维基百科文章中所述，数学家杰弗里·拉加里亚斯指出，科拉茨猜想“是一个极其困难的问题，完全超出了当今数学的范围”。</p><h2 id="作业" tabindex="-1">作业 <a class="header-anchor" href="#作业" aria-label="Permalink to &quot;作业&quot;">​</a></h2>`,67)]))}const u=a(p,[["render",o]]);export{g as __pageData,u as default};
